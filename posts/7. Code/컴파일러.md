---
page-title: "컴파일러 - 위키백과, 우리 모두의 백과사전"
url: https://ko.wikipedia.org/wiki/컴파일러
date: "2023-04-09 22:22:33"
---
# 1. 의의
- **컴파일러**(compiler, 순화 용어: 해석기, 번역기)는 
	- 특정 프로그래밍 언어로 쓰여 있는 문서를 다른 프로그래밍 언어로 옮기는 **언어 번역 프로그램**을 말한다. 
	- **컴파일러**는 ==고급 프로그래밍 언어를 실행 프로그램으로 만들기 위해 저급 프로그래밍 언어(예, 어셈블리 언어, object 코드, machine code)로 바꾸는 데 사용==된다. 
## 가. 용어정의
- 원래의 문서를 소스 코드 혹은 원시 코드라고 부르고, 출력된 문서를 목적 코드라고 부른다. 목적 코드는 주로 다른 프로그램이나 하드웨어가 처리하기에 용이한 형태로 출력되지만 사람이 읽을 수 있는 문서 파일이나 그림 파일 등으로 옮기는 경우도 있다. 원시 코드에서 목적 코드로 옮기는 과정을 **컴파일**(compile, 순화 용어: 옮김, 번역, 문화어: 콤파일)이라고 한다.
## 나. 구별개념
- 컴파일러는 ==소스 프로그램을 그대로 읽어서 즉시 결과를 출력하는 인터프리터와는 구분==된다. 
	- 그러나 현대에 들어 많은 인터프리터가 JIT 컴파일 등의 기술로 실시간 컴파일을 수행하므로, 컴파일러와 인터프리터 사이의 기술적 구분은 사라져 가는 추세이다.
- 소스 코드를 컴파일하는 이유는 대부분 사람에게 이해하기 쉬운 형태의 고수준 언어로부터 실행가능한 기계어 프로그램을 만들기 위해서이다. 좁은 의미의 컴파일러는 주로 고수준 언어로 쓰인 소스 코드를 저수준 언어(어셈블리어, 기계어 등)로 번역하는 프로그램을 가리킨다.
# 2. 역사
초기 컴퓨터 프로그램들은 어셈블리어로 작성되었다. 그러나 서로 다른 CPU 아키텍처가 등장할 때마다 매번 똑같은 프로그램을 서로 다른 어셈블리어로 작성하는 비용이 커지면서, 고급 프로그래밍 언어의 필요성이 대두되었다. 그러나 초기 컴퓨터 하드웨어의 메모리 크기가 너무 작아, 컴파일러의 등장에 기술적 장애물이 되었다.
1950년대 초부터 기계어에 독립적인 최초의 고급 프로그래밍 언어가 나타났고, 실험적인 컴파일러들이 등장하기 시작했다. 세계 최초의 컴파일러는 1952년 그레이스 호퍼가 개발한 프로그래밍 언어 A-0를 기계어로 번역하는 컴파일러이다. 컴파일러라는 용어 또한 이때 호퍼가 처음 사용하였다. 최적화 기능이 탑재된 최초의 "완전한" 컴파일러는 1957년 IBM의 존 배커스가 개발한 포트란 컴파일러이다.
# 3. 원리
컴파일러에서 꼭 지켜야 할 두 가지 조건이 있다. 첫째로, 컴파일러는 옮김의 과정에서 프로그램의 뜻을 보존하여야 한다. 입력받은 프로그램의 의미를 충실히 따라야 한다. 이런 조건이 없다면 컴파일러를 사용하는 사용자가 컴파일러를 믿고 프로그램을 작성할 수도 없고, 잘못된 옮김을 인정한다면 컴파일러를 올바르게 하기 위한 노력을 들일 필요가 없을 것이다. 두 번째로, 실용적인 면에서, 컴파일러는 입력으로 들어온 프로그램을 어떤 면에서든지 개선해야 한다. 예를 들어, 소스 코드를 기계어로 옮긴다면 기계가 이해할 수 없었던 언어를 기계가 이해할 수 있게 개선한 것이 된다. 같은 언어로 옮긴 경우에는 성능이 개선되는 등의 장점이 있어야 한다. 그렇지 않다면 컴파일을 수행할 이유가 없어진다.
컴파일러의 기능:
- 고급언어를 직접 기계어 코드로 변환한다.
- 자바 "자바 (프로그래밍 언어)")의 경우 바이트 코드로 변환한다. 중간단계의 코드를 생성하고 이것을 해석해서 실행한다.
C/C++언어와 같은 고급언어는 직접 기계어 코드로 변환한다. 마이크로프로세서는 각각 다른 기계어 코드를 가지고 있기 때문에 같은 고급언어라도 다른 기계어 코드를 생성해야 한다. 따라서 개발자는 해당 마이크로프로세서에 맞는 컴파일러를 사용해야 한다. 그러나 자바 "자바 (프로그래밍 언어)")는 다양한 마이크로프로세서에서 실행되도록 하는 철학을 가지고 개발되었기 때문에 바이트 코드를 가지고 해석을 해서 실행하는 방식이다. 장점은 한번 컴파일된 바이트 코드는 다른 플랫폼에서 재컴파일없이 실행할 수 있다. 그러나 단점은 바이트 코드를 해석해서 실행할 프로그램 구조가 필요하고, 직접 기계어 코드를 실행하는 것 보다 속도에서 늦다.
# 4. 컴파일러의 실행 단계
많은 수의 컴파일러는 다음과 같은 순서를 거쳐 소스 코드를 번역한다. 컴파일러나 프로그래밍 언어의 특성에 따라 일부 단계는 생략되거나 더 세부적인 단계로 나뉠 수도 있다.
- 구문 분석: 소스 코드 파일을 읽어 개별 문법요소(연산자, 괄호, 식별자 등) 단위로 자른후, 이 문법요소들을 해석하여 추상 구문 트리를 생성한다. 이 과정에서 문법에 맞지 않는 소스 코드는 사용자에게 알려준다.
- 최적화: 추상 구문 트리를 분석하여 최적화를 수행한다. 도달할 수 없는 코드를 식별하거나, 상수 표현식을 미리 계산해 두거나, 루프 풀기 등의 대부분의 최적화가 이 단계에서 수행된다.
- 코드 생성: 최적화된 구문 트리로부터 목적 코드를 생성한다. 목표 언어가 기계어일 경우, 레지스터 할당, 연산 순서 바꾸기 등 하드웨어에 맞는 최적화가 이 단계에서 수행된다. 대부분의 하드웨어 최적화 알고리즘은 NP "NP (복잡도)") 복잡도를 갖지만, 휴리스틱을 통해 많은 최적화가 수행된다.
- 링킹: 목적 코드가 기계어일 경우, 여러 라이브러리 목적 코드를 묶어 하나의 실행 파일을 생성하게 된다. 이 과정은 링커 "링커 (컴퓨팅)")에 의해 수행되며, 어떤 사람들은 링커를 컴파일러의 일부로 간주하지 않기도 한다.
## 1) 목적코드가 실행되는 방법\[편집\]
컴파일러가 실행되는 컴퓨터나 운영체제가 컴파일러의 목적코드가 실행될 컴퓨터나 운영체제와 같은 경우 네이티브 컴파일러(native compiler 또는 hosted compiler)라고 한다.
**네이티브 컴파일러** 예:
- 마이크로소프트 윈도우용 응용 프로그램 개발하기 비주얼 스튜디오로 컴파일하면 실행파일(exe 파일) 생성한다.
- 리눅스용 응용 프로그램 개발하기 위해 x86용 gcc를 사용하면 리눅스 실행파일이 생성된다.
반면에 크로스 컴파일러(cross compiler)는 다른 컴퓨터나 운영체제에서 실행되도록 제작된다. 임베디드 시스템 등 소프트웨어 개발에 충분한 환경을 갖추지 못한 환경에서 동작할 프로그램을 만들기 위해 사용된다.
**크로스 컴파일러** 예 :
- 리눅스(x86)에서 ARM용 임베디드 시스템용 프로그램이나 커널을 개발하기 위해 ARM용 gcc을 사용하면 ARM 코드의 실행파일이 생성된다.
- 마이크로소프트 윈도에서 8051, AVR, PIC등의 시스템 프로그램을 개발하기 위해 해당 컴파일러를 사용하면 해당 CPU의 코드가 생성된다.
## 2) 자바
또한 가상 머신에서 동작할 프로그램을 만드는 컴파일러도 있다. 이 경우 일반적으로 출력물이 가상 머신을 위해 제작된 바이트코드 형태의 기계어가 되므로 바이트코드 컴파일러라고 부른다.
## 3) 일단 구조와 다단 구조\[편집\]
소스를 한 번 읽고 번역하여 바로 출력물을 내놓는 컴파일러도 있지만 여러 가지 목적을 위해 중간 결과를 만들어 그 결과를 다시 최종 결과로 출력하는 컴파일러도 있다. 중간 결과를 만드는 데는 여러 가지 이유가 있다.
- 다양한 언어 지원 : 다양한 입력 언어를 동일한 중간 표현으로 표현하거나 동일한 중간 표현을 여러 가지 출력 언어로 표현하면 다양한 입력 언어와 출력 언어를 지원하는 컴파일러를 작성할 수 있다.
- 속도 및 최적화 : 고수준 언어일수록 최적화된 성능보다는 사람에게 이해하기 쉬운 형태를 염두에 두고 설계된다. 때문에 중간형태를 거치는 것이 보다 저수준에서 효율적으로 프로그램을 최적화한 다음 최종적으로 출력물을 내놓는 데 유리할 수 있다.
- 저스트 인 타임 컴파일 (JIT 컴파일) : 스몰토크, 자바 "자바 (프로그래밍 언어)"), 마이크로소프트 공통 중간 언어(CIL) 등의 컴파일러는 가상 머신의 바이트코드를 출력한다. 그러나 가상 머신은 플랫폼의 기계어에 비해 속도가 느릴 수밖에 없으므로 이들 가상 머신에는 저스트 인 타임 컴파일러가 탑재되어 실행 직전에 현재 플랫폼의 기계어로 다시 한 번 컴파일되어 속도를 향상시킨다.